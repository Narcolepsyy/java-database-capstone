<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/project/back_end/controllers/ViewController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/project/back_end/controllers/ViewController.java" />
              <option name="originalContent" value="package com.project.back_end.controllers;&#10;&#10;import org.springframework.stereotype.Controller;&#10;import org.springframework.web.bind.annotation.GetMapping;&#10;import org.springframework.ui.Model;&#10;import jakarta.servlet.http.HttpServletRequest;&#10;&#10;@Controller&#10;public class ViewController {&#10;&#10;    @GetMapping(&quot;/admin/dashboard&quot;)&#10;    public String adminDashboard() {&#10;        return &quot;admin/adminDashboard&quot;;&#10;    }&#10;&#10;    @GetMapping(&quot;/admin/test&quot;)&#10;    public String adminTest() {&#10;        return &quot;redirect:/admin/dashboard&quot;;&#10;    }&#10;&#10;    @GetMapping(&quot;/doctor/dashboard&quot;)&#10;    public String doctorDashboard(HttpServletRequest request, Model model) {&#10;        try {&#10;            // Add any necessary model attributes here if needed&#10;            return &quot;doctor/doctorDashboard&quot;;&#10;        } catch (Exception e) {&#10;            System.err.println(&quot;Error loading doctor dashboard: &quot; + e.getMessage());&#10;            return &quot;redirect:/&quot;;&#10;        }&#10;    }&#10;&#10;    @GetMapping(&quot;/patient/dashboard&quot;)&#10;    public String patientDashboard(HttpServletRequest request, Model model) {&#10;        try {&#10;            // Return the forward path to the static HTML file&#10;            return &quot;forward:/pages/loggedPatientDashboard.html&quot;;&#10;        } catch (Exception e) {&#10;            System.err.println(&quot;Error loading patient dashboard: &quot; + e.getMessage());&#10;            return &quot;redirect:/&quot;;&#10;        }&#10;    }&#10;&#10;    // Add a new mapping for the non-authenticated patient dashboard&#10;    @GetMapping(&quot;/patient&quot;)&#10;    public String patientLanding() {&#10;        return &quot;forward:/pages/patientDashboard.html&quot;;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.project.back_end.controllers;&#10;&#10;import org.springframework.stereotype.Controller;&#10;import org.springframework.web.bind.annotation.GetMapping;&#10;import org.springframework.ui.Model;&#10;import jakarta.servlet.http.HttpServletRequest;&#10;&#10;@Controller&#10;public class ViewController {&#10;&#10;    @GetMapping(&quot;/admin/dashboard&quot;)&#10;    public String adminDashboard() {&#10;        return &quot;admin/adminDashboard&quot;;&#10;    }&#10;&#10;    @GetMapping(&quot;/admin/test&quot;)&#10;    public String adminTest() {&#10;        return &quot;redirect:/admin/dashboard&quot;;&#10;    }&#10;&#10;    @GetMapping(&quot;/doctor/dashboard&quot;)&#10;    public String doctorDashboard(HttpServletRequest request, Model model) {&#10;        try {&#10;            // Add any necessary model attributes here if needed&#10;            return &quot;doctor/doctorDashboard&quot;;&#10;        } catch (Exception e) {&#10;            System.err.println(&quot;Error loading doctor dashboard: &quot; + e.getMessage());&#10;            return &quot;redirect:/&quot;;&#10;        }&#10;    }&#10;&#10;    @GetMapping(&quot;/patient/dashboard&quot;)&#10;    public String patientDashboard(HttpServletRequest request, Model model) {&#10;        try {&#10;            // Simply use forward without the /pages/ prefix&#10;            return &quot;forward:/loggedPatientDashboard.html&quot;;&#10;        } catch (Exception e) {&#10;            System.err.println(&quot;Error loading patient dashboard: &quot; + e.getMessage());&#10;            return &quot;redirect:/&quot;;&#10;        }&#10;    }&#10;    &#10;    @GetMapping(&quot;/patient&quot;)&#10;    public String patientLanding() {&#10;        return &quot;forward:/patientDashboard.html&quot;;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/project/back_end/mvc/DashboardController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/project/back_end/mvc/DashboardController.java" />
              <option name="originalContent" value="package com.project.back_end.mvc;&#10;&#10;import com.project.back_end.services.Service;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.stereotype.Controller;&#10;import org.springframework.web.bind.annotation.GetMapping;&#10;import org.springframework.web.bind.annotation.PathVariable;&#10;&#10;import java.nio.file.Path;&#10;import java.util.Map;&#10;&#10;@Controller&#10;public class DashboardController {&#10;&#10;// 1. Set Up the MVC Controller Class:&#10;//    - Annotate the class with `@Controller` to indicate that it serves as an MVC controller returning view names (not JSON).&#10;//    - This class handles routing to admin and doctor dashboard pages based on token validation.&#10;&#10;&#10;// 2. Autowire the Shared Service:&#10;//    - Inject the common `Service` class, which provides the token validation logic used to authorize access to dashboards.&#10;@Autowired&#10;    Service service;&#10;&#10;&#10;// 3. Define the `adminDashboard` Method:&#10;//    - Handles HTTP GET requests to `/adminDashboard/{token}`.&#10;//    - Accepts an admin's token as a path variable.&#10;//    - Validates the token using the shared service for the `&quot;admin&quot;` role.&#10;//    - If the token is valid (i.e., no errors returned), forwards the user to the `&quot;admin/adminDashboard&quot;` view.&#10;//    - If invalid, redirects to the root URL, likely the login or home page.&#10;@GetMapping(&quot;/adminDashboard/{token}&quot;)&#10;public String adminDashboard(@PathVariable String token)&#10;{&#10;    Map&lt;String, String&gt; map=service.validateToken(token,&quot;admin&quot;).getBody();&#10;    System.out.println(&quot;map&quot;+map);&#10;    if(map.isEmpty())&#10;    {&#10;        return &quot;admin/adminDashboard&quot;;&#10;    }&#10;    return &quot;redirect:http://localhost:8080&quot;;&#10;&#10;}&#10;&#10;&#10;    // 4. Define the `doctorDashboard` Method:&#10;//    - Handles HTTP GET requests to `/doctorDashboard/{token}`.&#10;//    - Accepts a doctor's token as a path variable.&#10;//    - Validates the token using the shared service for the `&quot;doctor&quot;` role.&#10;//    - If the token is valid, forwards the user to the `&quot;doctor/doctorDashboard&quot;` view.&#10;//    - If the token is invalid, redirects to the root URL.&#10;    @GetMapping(&quot;/doctorDashboard/{token}&quot;)&#10;    public String doctorDashboard(@PathVariable String token)&#10;    {&#10;        Map&lt;String, String&gt; map=service.validateToken(token,&quot;doctor&quot;).getBody();&#10;        System.out.println(&quot;map&quot;+map);&#10;        if(map.isEmpty())&#10;        {&#10;            return &quot;doctor/doctorDashboard&quot;;&#10;        }&#10;&#10;        return &quot;redirect:http://localhost:8080&quot;;&#10;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.project.back_end.mvc;&#10;&#10;import com.project.back_end.services.Service;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.stereotype.Controller;&#10;import org.springframework.web.bind.annotation.GetMapping;&#10;import org.springframework.web.bind.annotation.PathVariable;&#10;&#10;import java.nio.file.Path;&#10;import java.util.Map;&#10;&#10;@Controller&#10;public class DashboardController {&#10;&#10;// 1. Set Up the MVC Controller Class:&#10;//    - Annotate the class with `@Controller` to indicate that it serves as an MVC controller returning view names (not JSON).&#10;//    - This class handles routing to admin and doctor dashboard pages based on token validation.&#10;&#10;&#10;// 2. Autowire the Shared Service:&#10;//    - Inject the common `Service` class, which provides the token validation logic used to authorize access to dashboards.&#10;@Autowired&#10;    Service service;&#10;&#10;&#10;// 3. Define the `adminDashboard` Method:&#10;//    - Handles HTTP GET requests to `/adminDashboard/{token}`.&#10;//    - Accepts an admin's token as a path variable.&#10;//    - Validates the token using the shared service for the `&quot;admin&quot;` role.&#10;//    - If the token is valid (i.e., no errors returned), forwards the user to the `&quot;admin/adminDashboard&quot;` view.&#10;//    - If invalid, redirects to the root URL, likely the login or home page.&#10;@GetMapping(&quot;/adminDashboard/{token}&quot;)&#10;public String adminDashboard(@PathVariable String token)&#10;{&#10;    Map&lt;String, String&gt; map=service.validateToken(token,&quot;admin&quot;).getBody();&#10;    System.out.println(&quot;map&quot;+map);&#10;    if(map.isEmpty())&#10;    {&#10;        return &quot;admin/adminDashboard&quot;;&#10;    }&#10;    return &quot;redirect:http://localhost:8080&quot;;&#10;&#10;}&#10;&#10;&#10;    // 4. Define the `doctorDashboard` Method:&#10;//    - Handles HTTP GET requests to `/doctorDashboard/{token}`.&#10;//    - Accepts a doctor's token as a path variable.&#10;//    - Validates the token using the shared service for the `&quot;doctor&quot;` role.&#10;//    - If the token is valid, forwards the user to the `&quot;doctor/doctorDashboard&quot;` view.&#10;//    - If the token is invalid, redirects to the root URL.&#10;    @GetMapping(&quot;/doctorDashboard/{token}&quot;)&#10;    public String doctorDashboard(@PathVariable String token)&#10;    {&#10;        Map&lt;String, String&gt; map=service.validateToken(token,&quot;doctor&quot;).getBody();&#10;        System.out.println(&quot;map&quot;+map);&#10;        if(map.isEmpty())&#10;        {&#10;            return &quot;doctor/doctorDashboard&quot;;&#10;        }&#10;&#10;        return &quot;redirect:http://localhost:8080&quot;;&#10;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/project/back_end/repo/DoctorRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/project/back_end/repo/DoctorRepository.java" />
              <option name="originalContent" value="package com.project.back_end.repo;&#10;&#10;import com.project.back_end.models.Doctor;&#10;import org.springframework.data.jpa.repository.JpaRepository;&#10;import org.springframework.data.jpa.repository.Query;&#10;import org.springframework.stereotype.Repository;&#10;&#10;import javax.print.Doc;&#10;import java.util.List;&#10;@Repository&#10;public interface DoctorRepository extends JpaRepository&lt;Doctor, Long&gt; {&#10;   // 1. Extend JpaRepository:&#10;//    - The repository extends JpaRepository&lt;Doctor, Long&gt;, which gives it basic CRUD functionality.&#10;//    - This allows the repository to perform operations like save, delete, update, and find without needing to implement these methods manually.&#10;//    - JpaRepository also includes features like pagination and sorting.&#10;&#10;// Example: public interface DoctorRepository extends JpaRepository&lt;Doctor, Long&gt; {}&#10;&#10;// 2. Custom Query Methods:&#10;&#10;//    - **findByEmail**:&#10;//      - This method retrieves a Doctor by their email.&#10;//      - Return type: Doctor&#10;//      - Parameters: String email&#10;    @Query(&quot;SELECT d FROM Doctor d WHERE d.email = :email&quot;)&#10;Doctor findByEmail(String email);&#10;//    - **findByNameLike**:&#10;//      - This method retrieves a list of Doctors whose name contains the provided search string (case-sensitive).&#10;//      - The `CONCAT('%', :name, '%')` is used to create a pattern for partial matching.&#10;//      - Return type: List&lt;Doctor&gt;&#10;//      - Parameters: String name&#10;    @Query(&quot;SELECT d FROM Doctor  d WHERE d.name LIKE CONCAT('%', :name, '%')&quot;)&#10;List&lt;Doctor&gt; findByNameLike(String name);&#10;//    - **findByNameContainingIgnoreCaseAndSpecialtyIgnoreCase**:&#10;//      - This method retrieves a list of Doctors where the name contains the search string (case-insensitive) and the specialty matches exactly (case-insensitive).&#10;//      - It combines both fields for a more specific search.&#10;//      - Return type: List&lt;Doctor&gt;&#10;//      - Parameters: String name, String specialty&#10;    @Query(&quot;SELECT d FROM Doctor d WHERE LOWER(d.name) LIKE LOWER(CONCAT('%', :name, '%')) AND LOWER(d.specialty) = LOWER(:speciality)&quot;)&#10;List&lt;Doctor&gt; findByNameContainingIgnoreCaseAndSpecialtyIgnoreCase(String name, String specialty);&#10;//    - **findBySpecialtyIgnoreCase**:&#10;//      - This method retrieves a list of Doctors with the specified specialty, ignoring case sensitivity.&#10;//      - Return type: List&lt;Doctor&gt;&#10;//      - Parameters: String specialty&#10;    @Query(&quot;SELECT d FROM Doctor d WHERE LOWER(d.specialty) = LOWER(:specialty)&quot;)&#10;List&lt;Doctor&gt; findBySpecialtyIgnoreCase(String specialty);&#10;// 3. @Repository annotation:&#10;//    - The @Repository annotation marks this interface as a Spring Data JPA repository.&#10;//    - Spring Data JPA automatically implements this repository, providing the necessary CRUD functionality and custom queries defined in the interface.&#10;&#10;}" />
              <option name="updatedContent" value="package com.project.back_end.repo;&#10;&#10;import com.project.back_end.models.Doctor;&#10;import org.springframework.data.jpa.repository.JpaRepository;&#10;import org.springframework.data.jpa.repository.Query;&#10;import org.springframework.stereotype.Repository;&#10;&#10;import javax.print.Doc;&#10;import java.util.List;&#10;@Repository&#10;public interface DoctorRepository extends JpaRepository&lt;Doctor, Long&gt; {&#10;   // 1. Extend JpaRepository:&#10;//    - The repository extends JpaRepository&lt;Doctor, Long&gt;, which gives it basic CRUD functionality.&#10;//    - This allows the repository to perform operations like save, delete, update, and find without needing to implement these methods manually.&#10;//    - JpaRepository also includes features like pagination and sorting.&#10;&#10;// Example: public interface DoctorRepository extends JpaRepository&lt;Doctor, Long&gt; {}&#10;&#10;// 2. Custom Query Methods:&#10;&#10;//    - **findByEmail**:&#10;//      - This method retrieves a Doctor by their email.&#10;//      - Return type: Doctor&#10;//      - Parameters: String email&#10;    @Query(&quot;SELECT d FROM Doctor d WHERE d.email = :email&quot;)&#10;Doctor findByEmail(String email);&#10;//    - **findByNameLike**:&#10;//      - This method retrieves a list of Doctors whose name contains the provided search string (case-sensitive).&#10;//      - The `CONCAT('%', :name, '%')` is used to create a pattern for partial matching.&#10;//      - Return type: List&lt;Doctor&gt;&#10;//      - Parameters: String name&#10;    @Query(&quot;SELECT d FROM Doctor  d WHERE d.name LIKE CONCAT('%', :name, '%')&quot;)&#10;List&lt;Doctor&gt; findByNameLike(String name);&#10;//    - **findByNameContainingIgnoreCaseAndSpecialtyIgnoreCase**:&#10;//      - This method retrieves a list of Doctors where the name contains the search string (case-insensitive) and the specialty matches exactly (case-insensitive).&#10;//      - It combines both fields for a more specific search.&#10;//      - Return type: List&lt;Doctor&gt;&#10;//      - Parameters: String name, String specialty&#10;    @Query(&quot;SELECT d FROM Doctor d WHERE LOWER(d.name) LIKE LOWER(CONCAT('%', :name, '%')) AND LOWER(d.specialty) = LOWER(:speciality)&quot;)&#10;List&lt;Doctor&gt; findByNameContainingIgnoreCaseAndSpecialtyIgnoreCase(String name, String specialty);&#10;//    - **findBySpecialtyIgnoreCase**:&#10;//      - This method retrieves a list of Doctors with the specified specialty, ignoring case sensitivity.&#10;//      - Return type: List&lt;Doctor&gt;&#10;//      - Parameters: String specialty&#10;    @Query(&quot;SELECT d FROM Doctor d WHERE LOWER(d.specialty) = LOWER(:specialty)&quot;)&#10;List&lt;Doctor&gt; findBySpecialtyIgnoreCase(String specialty);&#10;// 3. @Repository annotation:&#10;//    - The @Repository annotation marks this interface as a Spring Data JPA repository.&#10;//    - Spring Data JPA automatically implements this repository, providing the necessary CRUD functionality and custom queries defined in the interface.&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/project/back_end/services/AppointmentService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/project/back_end/services/AppointmentService.java" />
              <option name="originalContent" value="// AppointmentService.java&#10;package com.project.back_end.services;&#10;&#10;import com.project.back_end.DTO.AppointmentDTO;&#10;import com.project.back_end.models.Appointment;&#10;import com.project.back_end.models.Patient;&#10;import com.project.back_end.repo.AppointmentRepository;&#10;import com.project.back_end.repo.DoctorRepository;&#10;import com.project.back_end.repo.PatientRepository;&#10;import jakarta.transaction.Transactional;&#10;import org.springframework.http.HttpStatus;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.stereotype.Service;&#10;&#10;import java.time.LocalDate;&#10;import java.time.LocalDateTime;&#10;import java.time.LocalTime;&#10;import java.util.HashMap;&#10;import java.util.List;&#10;import java.util.Map;&#10;import java.util.Optional;&#10;import java.util.stream.Collectors;&#10;&#10;@Service&#10;public class AppointmentService {&#10;&#10;    private final AppointmentRepository appointmentRepository;&#10;    private final com.project.back_end.services.Service service;&#10;    private final TokenService tokenService;&#10;    private final PatientRepository patientRepository;&#10;    private final DoctorRepository doctorRepository;&#10;&#10;    public AppointmentService(AppointmentRepository appointmentRepository,&#10;            com.project.back_end.services.Service service, TokenService tokenService,&#10;            PatientRepository patientRepository, DoctorRepository doctorRepository) {&#10;        this.appointmentRepository = appointmentRepository;&#10;        this.service = service;&#10;        this.tokenService = tokenService;&#10;        this.patientRepository = patientRepository;&#10;        this.doctorRepository = doctorRepository;&#10;    }&#10;&#10;    public int bookAppointment(Appointment appointment) {&#10;        try {&#10;            appointmentRepository.save(appointment);&#10;            return 1;&#10;        } catch (Exception e) {&#10;            System.out.println(&quot;Error: &quot; + e);&#10;            return 0;&#10;        }&#10;    }&#10;&#10;    public ResponseEntity&lt;Map&lt;String, String&gt;&gt; updateAppointment(Appointment appointment) {&#10;        Map&lt;String, String&gt; response = new HashMap&lt;&gt;();&#10;&#10;        Optional&lt;Appointment&gt; result = appointmentRepository.findById(appointment.getId());&#10;        if (!result.isPresent()) {&#10;            response.put(&quot;message&quot;, &quot;No appointment available with id: &quot; + appointment.getId());&#10;            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);&#10;        }&#10;&#10;        if (result.get().getPatient().getId() != appointment.getPatient().getId()) {&#10;            response.put(&quot;message&quot;, &quot;Patient Id mismatch&quot;);&#10;            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(response);&#10;        }&#10;        int out = service.validateAppointment(appointment);&#10;        if (out == 1) {&#10;            try {&#10;                appointmentRepository.save(appointment);&#10;                response.put(&quot;message&quot;, &quot;Appointment Updated Successfully&quot;);&#10;                return ResponseEntity.status(HttpStatus.OK).body(response);&#10;&#10;            } catch (Exception e) {&#10;                System.out.println(&quot;Error: &quot; + e);&#10;                response.put(&quot;message&quot;, &quot;Internal Server Error&quot;);&#10;                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);&#10;            }&#10;&#10;        } else if (out == -1) {&#10;            response.put(&quot;message&quot;, &quot;Invalid doctor id&quot;);&#10;            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(response);&#10;        }&#10;&#10;        response.put(&quot;message&quot;, &quot;Appointment already booked for given time or Doctor not available&quot;);&#10;        return ResponseEntity.status(HttpStatus.CONFLICT).body(response);&#10;&#10;    }&#10;&#10;    public ResponseEntity&lt;Map&lt;String, String&gt;&gt; cancelAppointment(long id, String token) {&#10;        Map&lt;String, String&gt; response = new HashMap&lt;&gt;();&#10;        Optional&lt;Appointment&gt; appointment = appointmentRepository.findById(id);&#10;        String extractedToken = tokenService.extractEmail(token);&#10;        Patient patient = patientRepository.findByEmail(extractedToken);&#10;        if (patient.getId() != appointment.get().getPatient().getId()) {&#10;            response.put(&quot;message&quot;, &quot;Patient Id mismatch&quot;);&#10;            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(response);&#10;        }&#10;&#10;        if (appointment.isPresent()) {&#10;            try {&#10;                appointmentRepository.delete(appointment.get());&#10;                response.put(&quot;message&quot;, &quot;Appointment Deleted Successfully&quot;);&#10;                return ResponseEntity.status(HttpStatus.OK).body(response);&#10;            } catch (Exception e) {&#10;                System.out.println(&quot;Error: &quot; + e);&#10;                response.put(&quot;message&quot;, &quot;Internal Server Error&quot;);&#10;                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);&#10;            }&#10;        }&#10;        response.put(&quot;message&quot;, &quot;No appointment for given id: &quot; + id);&#10;        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);&#10;    }&#10;&#10;    @Transactional&#10;    public Map&lt;String, Object&gt; getAppointment(String pname, LocalDate date, String token) {&#10;        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();&#10;        String extractedEmail = tokenService.extractEmail(token);&#10;        Long doctorId = doctorRepository.findByEmail(extractedEmail).getId();&#10;        LocalDateTime startOfDay = date.atStartOfDay();&#10;        LocalDateTime endOfDay = date.atTime(LocalTime.MAX);&#10;&#10;        List&lt;Appointment&gt; appointments;&#10;&#10;        if (pname.equals(&quot;null&quot;)) {&#10;            // If pname is null or empty, fetch all appointments for that date&#10;&#10;            appointments = appointmentRepository&#10;                    .findByDoctorIdAndAppointmentTimeBetween(doctorId, startOfDay, endOfDay);&#10;        } else {&#10;            // Filter by patient name&#10;            appointments = appointmentRepository&#10;                    .findByDoctorIdAndPatient_NameContainingIgnoreCaseAndAppointmentTimeBetween(&#10;                            doctorId, pname, startOfDay, endOfDay);&#10;        }&#10;&#10;        List&lt;AppointmentDTO&gt; appointmentDTOs = appointments.stream()&#10;                .map(app -&gt; new AppointmentDTO(&#10;                        app.getId(),&#10;                        app.getDoctor().getId(), // Simplified doctor info&#10;                        app.getDoctor().getName(),&#10;                        app.getPatient().getId(),&#10;                        app.getPatient().getName(),&#10;                        app.getPatient().getEmail(),&#10;                        app.getPatient().getPhone(),&#10;                        app.getPatient().getAddress(),&#10;                        app.getAppointmentTime(),&#10;                        app.getStatus()))&#10;                .collect(Collectors.toList());&#10;&#10;        map.put(&quot;appointments&quot;, appointmentDTOs);&#10;        return map;&#10;&#10;    }&#10;&#10;    @Transactional&#10;    public void changeStatus(long appointmentId)&#10;    {&#10;        appointmentRepository.updateStatus(1, appointmentId);&#10;    }&#10;&#10;}&#10;" />
              <option name="updatedContent" value="// AppointmentService.java&#10;package com.project.back_end.services;&#10;&#10;import com.project.back_end.DTO.AppointmentDTO;&#10;import com.project.back_end.models.Appointment;&#10;import com.project.back_end.models.Patient;&#10;import com.project.back_end.repo.AppointmentRepository;&#10;import com.project.back_end.repo.DoctorRepository;&#10;import com.project.back_end.repo.PatientRepository;&#10;import jakarta.transaction.Transactional;&#10;import org.springframework.http.HttpStatus;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.stereotype.Service;&#10;&#10;import java.time.LocalDate;&#10;import java.time.LocalDateTime;&#10;import java.time.LocalTime;&#10;import java.util.HashMap;&#10;import java.util.List;&#10;import java.util.Map;&#10;import java.util.Optional;&#10;import java.util.stream.Collectors;&#10;&#10;@Service&#10;public class AppointmentService {&#10;&#10;    private final AppointmentRepository appointmentRepository;&#10;    private final com.project.back_end.services.Service service;&#10;    private final TokenService tokenService;&#10;    private final PatientRepository patientRepository;&#10;    private final DoctorRepository doctorRepository;&#10;&#10;    public AppointmentService(AppointmentRepository appointmentRepository,&#10;            com.project.back_end.services.Service service, TokenService tokenService,&#10;            PatientRepository patientRepository, DoctorRepository doctorRepository) {&#10;        this.appointmentRepository = appointmentRepository;&#10;        this.service = service;&#10;        this.tokenService = tokenService;&#10;        this.patientRepository = patientRepository;&#10;        this.doctorRepository = doctorRepository;&#10;    }&#10;&#10;    public int bookAppointment(Appointment appointment) {&#10;        try {&#10;            appointmentRepository.save(appointment);&#10;            return 1;&#10;        } catch (Exception e) {&#10;            System.out.println(&quot;Error: &quot; + e);&#10;            return 0;&#10;        }&#10;    }&#10;&#10;    public ResponseEntity&lt;Map&lt;String, String&gt;&gt; updateAppointment(Appointment appointment) {&#10;        Map&lt;String, String&gt; response = new HashMap&lt;&gt;();&#10;&#10;        Optional&lt;Appointment&gt; result = appointmentRepository.findById(appointment.getId());&#10;        if (!result.isPresent()) {&#10;            response.put(&quot;message&quot;, &quot;No appointment available with id: &quot; + appointment.getId());&#10;            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);&#10;        }&#10;&#10;        if (result.get().getPatient().getId() != appointment.getPatient().getId()) {&#10;            response.put(&quot;message&quot;, &quot;Patient Id mismatch&quot;);&#10;            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(response);&#10;        }&#10;        int out = service.validateAppointment(appointment);&#10;        if (out == 1) {&#10;            try {&#10;                appointmentRepository.save(appointment);&#10;                response.put(&quot;message&quot;, &quot;Appointment Updated Successfully&quot;);&#10;                return ResponseEntity.status(HttpStatus.OK).body(response);&#10;&#10;            } catch (Exception e) {&#10;                System.out.println(&quot;Error: &quot; + e);&#10;                response.put(&quot;message&quot;, &quot;Internal Server Error&quot;);&#10;                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);&#10;            }&#10;&#10;        } else if (out == -1) {&#10;            response.put(&quot;message&quot;, &quot;Invalid doctor id&quot;);&#10;            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(response);&#10;        }&#10;&#10;        response.put(&quot;message&quot;, &quot;Appointment already booked for given time or Doctor not available&quot;);&#10;        return ResponseEntity.status(HttpStatus.CONFLICT).body(response);&#10;&#10;    }&#10;&#10;    public ResponseEntity&lt;Map&lt;String, String&gt;&gt; cancelAppointment(long id, String token) {&#10;        Map&lt;String, String&gt; response = new HashMap&lt;&gt;();&#10;        &#10;        // First check if appointment exists&#10;        Optional&lt;Appointment&gt; appointmentOpt = appointmentRepository.findById(id);&#10;        if (appointmentOpt.isEmpty()) {&#10;            response.put(&quot;message&quot;, &quot;No appointment for given id: &quot; + id);&#10;            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);&#10;        }&#10;        &#10;        Appointment appointment = appointmentOpt.get();&#10;        &#10;        // Extract patient from token&#10;        try {&#10;            String extractedToken = tokenService.extractEmail(token);&#10;            Patient patient = patientRepository.findByEmail(extractedToken);&#10;            &#10;            // Check if patient exists&#10;            if (patient == null) {&#10;                response.put(&quot;message&quot;, &quot;Invalid patient token&quot;);&#10;                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(response);&#10;            }&#10;            &#10;            // Check if patient owns this appointment&#10;            if (patient.getId() != appointment.getPatient().getId()) {&#10;                response.put(&quot;message&quot;, &quot;Patient is not authorized to cancel this appointment&quot;);&#10;                return ResponseEntity.status(HttpStatus.FORBIDDEN).body(response);&#10;            }&#10;            &#10;            // Delete the appointment&#10;            appointmentRepository.delete(appointment);&#10;            response.put(&quot;message&quot;, &quot;Appointment Deleted Successfully&quot;);&#10;            return ResponseEntity.status(HttpStatus.OK).body(response);&#10;            &#10;        } catch (Exception e) {&#10;            System.err.println(&quot;Error canceling appointment: &quot; + e.getMessage());&#10;            e.printStackTrace();&#10;            response.put(&quot;message&quot;, &quot;Internal Server Error&quot;);&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);&#10;        }&#10;    }&#10;&#10;    @Transactional&#10;    public Map&lt;String, Object&gt; getAppointment(String pname, LocalDate date, String token) {&#10;        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();&#10;        String extractedEmail = tokenService.extractEmail(token);&#10;        Long doctorId = doctorRepository.findByEmail(extractedEmail).getId();&#10;        LocalDateTime startOfDay = date.atStartOfDay();&#10;        LocalDateTime endOfDay = date.atTime(LocalTime.MAX);&#10;&#10;        List&lt;Appointment&gt; appointments;&#10;&#10;        if (pname.equals(&quot;null&quot;)) {&#10;            // If pname is null or empty, fetch all appointments for that date&#10;&#10;            appointments = appointmentRepository&#10;                    .findByDoctorIdAndAppointmentTimeBetween(doctorId, startOfDay, endOfDay);&#10;        } else {&#10;            // Filter by patient name&#10;            appointments = appointmentRepository&#10;                    .findByDoctorIdAndPatient_NameContainingIgnoreCaseAndAppointmentTimeBetween(&#10;                            doctorId, pname, startOfDay, endOfDay);&#10;        }&#10;&#10;        List&lt;AppointmentDTO&gt; appointmentDTOs = appointments.stream()&#10;                .map(app -&gt; new AppointmentDTO(&#10;                        app.getId(),&#10;                        app.getDoctor().getId(), // Simplified doctor info&#10;                        app.getDoctor().getName(),&#10;                        app.getPatient().getId(),&#10;                        app.getPatient().getName(),&#10;                        app.getPatient().getEmail(),&#10;                        app.getPatient().getPhone(),&#10;                        app.getPatient().getAddress(),&#10;                        app.getAppointmentTime(),&#10;                        app.getStatus()))&#10;                .collect(Collectors.toList());&#10;&#10;        map.put(&quot;appointments&quot;, appointmentDTOs);&#10;        return map;&#10;&#10;    }&#10;&#10;    @Transactional&#10;    public void changeStatus(long appointmentId)&#10;    {&#10;        appointmentRepository.updateStatus(1, appointmentId);&#10;    }&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/project/back_end/services/DoctorService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/project/back_end/services/DoctorService.java" />
              <option name="originalContent" value="package com.project.back_end.services;&#10;&#10;import com.project.back_end.models.Appointment;&#10;import com.project.back_end.models.Doctor;&#10;import com.project.back_end.repo.AppointmentRepository;&#10;import com.project.back_end.repo.DoctorRepository;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.stereotype.Service;&#10;import org.springframework.transaction.annotation.Transactional;&#10;import com.project.back_end.DTO.Login;&#10;&#10;import javax.print.Doc;&#10;import java.time.LocalDate;&#10;import java.time.LocalDateTime;&#10;import java.time.LocalTime;&#10;import java.time.format.DateTimeFormatter;&#10;import java.util.*;&#10;import java.util.stream.Collectors;&#10;&#10;@Service&#10;public class DoctorService {&#10;&#10;// 1. **Add @Service Annotation**:&#10;//    - This class should be annotated with `@Service` to indicate that it is a service layer class.&#10;//    - The `@Service` annotation marks this class as a Spring-managed bean for business logic.&#10;//    - Instruction: Add `@Service` above the class declaration.&#10;&#10;// 2. **Constructor Injection for Dependencies**:&#10;//    - The `DoctorService` class depends on `DoctorRepository`, `AppointmentRepository`, and `TokenService`.&#10;//    - These dependencies should be injected via the constructor for proper dependency management.&#10;//    - Instruction: Ensure constructor injection is used for injecting dependencies into the service.&#10;private final DoctorRepository doctorRepository;&#10;private  final AppointmentRepository appointmentRepository;&#10;private  final TokenService tokenService;&#10;public DoctorService (DoctorRepository doctorRepository,&#10;                        AppointmentRepository appointmentRepository,&#10;                        TokenService tokenService) {&#10;    this.doctorRepository = doctorRepository;&#10;    this.appointmentRepository = appointmentRepository;&#10;    this.tokenService = tokenService;&#10;}&#10;// 3. **Add @Transactional Annotation for Methods that Modify or Fetch Database Data**:&#10;//    - Methods like `getDoctorAvailability`, `getDoctors`, `findDoctorByName`, `filterDoctorsBy*` should be annotated with `@Transactional`.&#10;//    - The `@Transactional` annotation ensures that database operations are consistent and wrapped in a single transaction.&#10;//    - Instruction: Add the `@Transactional` annotation above the methods that perform database operations or queries.&#10;&#10;// 4. **getDoctorAvailability Method**:&#10;//    - Retrieves the available time slots for a specific doctor on a particular date and filters out already booked slots.&#10;//    - The method fetches all appointments for the doctor on the given date and calculates the availability by comparing against booked slots.&#10;//    - Instruction: Ensure that the time slots are properly formatted and the available slots are correctly filtered.&#10;@Transactional&#10;public List&lt;String&gt; getDoctorAvailability(Long doctorId, LocalDate date) {&#10;    Optional&lt;Doctor&gt; doctor = doctorRepository.findById(doctorId);&#10;&#10;    if (doctor.isEmpty()) {&#10;        return List.of(&quot;Doctor not found with ID: &quot; + doctorId);&#10;    }&#10;&#10;    List&lt;String&gt; availableSlots = doctor.get().getAvailableTimes().stream()&#10;            .map(Object::toString)&#10;            .collect(Collectors.toList());&#10;&#10;    // Convert LocalDate to LocalDateTime (start and end of the day)&#10;    LocalDateTime startOfDay = date.atStartOfDay();&#10;    LocalDateTime endOfDay = date.atTime(LocalTime.MAX);&#10;&#10;    // Fetch the appointments for this doctor on the given date&#10;    List&lt;Appointment&gt; appointments = appointmentRepository.findByDoctorIdAndAppointmentTimeBetween(doctorId,&#10;            startOfDay, endOfDay);&#10;&#10;    // Set of booked slots for the doctor on this date&#10;    Set&lt;String&gt; bookedSlots = appointments.stream()&#10;            .map(appt -&gt; {&#10;                LocalDateTime start = appt.getAppointmentTime();&#10;                LocalDateTime end = start.plusHours(1); // Add 1 hour to the start time to get the end time&#10;                return formatSlot(start, end); // Format the slot as &quot;HH:mm-HH:mm&quot;&#10;            })&#10;            .collect(Collectors.toSet());&#10;&#10;    // Filter out booked slots from the available slots&#10;    return availableSlots.stream()&#10;            .filter(slot -&gt; !bookedSlots.contains(slot))&#10;            .collect(Collectors.toList());&#10;}&#10;private String formatSlot(LocalDateTime start, LocalDateTime end) {&#10;    DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;HH:mm&quot;);&#10;    return start.format(formatter) + &quot;-&quot; + end.format(formatter);&#10;}&#10;&#10;// 5. **saveDoctor Method**:&#10;//    - Used to save a new doctor record in the database after checking if a doctor with the same email already exists.&#10;//    - If a doctor with the same email is found, it returns `-1` to indicate conflict; `1` for success, and `0` for internal errors.&#10;//    - Instruction: Ensure that the method correctly handles conflicts and exceptions when saving a doctor.&#10;&#10;public int saveDoctor(Doctor doctor) {&#10;&#10;    // success: 1, conflict:-1, internal error: 0&#10;    Doctor result = doctorRepository.findByEmail(doctor.getEmail());&#10;&#10;    if (result != null) {&#10;        return -1;&#10;    }&#10;    try {&#10;        doctorRepository.save(doctor);&#10;        return 1;&#10;    } catch (Exception e) {&#10;        System.err.println(&quot;Error saving doctor: &quot; + e.getMessage());&#10;        return 0;&#10;    }&#10;&#10;}&#10;// 6. **updateDoctor Method**:&#10;//    - Updates an existing doctor's details in the database. If the doctor doesn't exist, it returns `-1`.&#10;//    - Instruction: Make sure that the doctor exists before attempting to save the updated record and handle any errors properly.&#10;&#10;public int updateDoctor(Doctor doctor) {&#10;    Optional&lt;Doctor&gt; existingDoctor = doctorRepository.findById(doctor.getId());&#10;    if (existingDoctor.isEmpty()) {&#10;        return -1; // Doctor not found&#10;    }&#10;    try {&#10;        doctorRepository.save(doctor);&#10;        return 1; // Update successful&#10;    } catch (Exception e) {&#10;        System.err.println(&quot;Error updating doctor: &quot; + e.getMessage());&#10;        return 0; // Internal error&#10;    }&#10;}&#10;// 7. **getDoctors Method**:&#10;//    - Fetches all doctors from the database. It is marked with `@Transactional` to ensure that the collection is properly loaded.&#10;//    - Instruction: Ensure that the collection is eagerly loaded, especially if dealing with lazy-loaded relationships (e.g., available times). &#10;@Transactional&#10;public List&lt;Doctor&gt; getDoctors() {&#10;    return doctorRepository.findAll();&#10;}&#10;// 8. **deleteDoctor Method**:&#10;//    - Deletes a doctor from the system along with all appointments associated with that doctor.&#10;//    - It first checks if the doctor exists. If not, it returns `-1`; otherwise, it deletes the doctor and their appointments.&#10;//    - Instruction: Ensure the doctor and their appointments are deleted properly, with error handling for internal issues.&#10;public int deleteDoctor(Long doctorId) {&#10;    Optional&lt;Doctor&gt; doctor = doctorRepository.findById(doctorId);&#10;    if (doctor.isEmpty()) {&#10;        return -1; // Doctor not found&#10;    }&#10;    try {&#10;        // Delete all appointments associated with the doctor&#10;        appointmentRepository.deleteAllByDoctorId(doctorId);&#10;        // Delete the doctor&#10;        doctorRepository.delete(doctor.get());&#10;        return 1; // Deletion successful&#10;    } catch (Exception e) {&#10;        System.err.println(&quot;Error deleting doctor: &quot; + e.getMessage());&#10;        return 0; // Internal error&#10;    }&#10;}&#10;&#10;// 9. **validateDoctor Method**:&#10;//    - Validates a doctor's login by checking if the email and password match an existing doctor record.&#10;//    - It generates a token for the doctor if the login is successful, otherwise returns an error message.&#10;//    - Instruction: Make sure to handle invalid login attempts and password mismatches properly with error responses.&#10;public ResponseEntity&lt;Map&lt;String, String&gt;&gt; ValidateDoctor(Login login) {&#10;    Map&lt;String, String&gt; map = new HashMap&lt;&gt;();&#10;    try {&#10;        System.out.println(&quot;=== DOCTOR LOGIN START ===&quot;);&#10;        System.out.println(&quot;Login attempt for email: &quot; + login.getEmail());&#10;&#10;        Doctor doctor = doctorRepository.findByEmail(login.getEmail());&#10;        if (doctor == null) {&#10;            System.out.println(&quot;Doctor not found in database for email: &quot; + login.getEmail());&#10;            map.put(&quot;message&quot;, &quot;Doctor not found&quot;);&#10;            return ResponseEntity.badRequest().body(map);&#10;        }&#10;&#10;        System.out.println(&quot;Doctor found: &quot; + doctor.getName() + &quot; (ID: &quot; + doctor.getId() + &quot;)&quot;);&#10;&#10;        if (!doctor.getPassword().equals(login.getPassword())) {&#10;            System.out.println(&quot;Password mismatch for doctor: &quot; + login.getEmail());&#10;            map.put(&quot;message&quot;, &quot;Invalid password&quot;);&#10;            return ResponseEntity.badRequest().body(map);&#10;        }&#10;&#10;        System.out.println(&quot;Password verified successfully&quot;);&#10;        System.out.println(&quot;Generating token for doctor email: &quot; + doctor.getEmail());&#10;&#10;        String token = tokenService.generateToken(doctor.getEmail());&#10;        System.out.println(&quot;Token generated successfully: &quot; + token.substring(0, Math.min(20, token.length())) + &quot;...&quot;);&#10;&#10;        map.put(&quot;token&quot;, token);&#10;        map.put(&quot;message&quot;, &quot;Login successful&quot;);&#10;        System.out.println(&quot;=== DOCTOR LOGIN SUCCESS ===&quot;);&#10;        return ResponseEntity.ok(map);&#10;    } catch (Exception e) {&#10;        System.err.println(&quot;Error in ValidateDoctor: &quot; + e.getMessage());&#10;        e.printStackTrace();&#10;        map.put(&quot;message&quot;, &quot;Internal error: &quot; + e.getMessage());&#10;        return ResponseEntity.status(500).body(map);&#10;    }&#10;}&#10;// 10. **findDoctorByName Method**:&#10;//    - Finds doctors based on partial name matching and returns the list of doctors with their available times.&#10;//    - This method is annotated with `@Transactional` to ensure that the database query and data retrieval are properly managed within a transaction.&#10;//    - Instruction: Ensure that available times are eagerly loaded for the doctors.&#10;public Map&lt;String, Object&gt; findDoctorByName(String name){&#10;    Map&lt;String, Object&gt; response = new HashMap&lt;&gt;();&#10;    List&lt;Doctor&gt; doctors = doctorRepository.findByNameLike(name);&#10;    if (doctors.isEmpty()) {&#10;        response.put(&quot;message&quot;, &quot;No doctors found with the name: &quot; + name);&#10;        return response;&#10;    }&#10;    List&lt;Map&lt;String, Object&gt;&gt; doctorDetails = new ArrayList&lt;&gt;();&#10;    for (Doctor doctor : doctors) {&#10;        Map&lt;String, Object&gt; doctorInfo = new HashMap&lt;&gt;();&#10;        doctorInfo.put(&quot;id&quot;, doctor.getId());&#10;        doctorInfo.put(&quot;name&quot;, doctor.getName());&#10;        doctorInfo.put(&quot;specialty&quot;, doctor.getSpecialty());&#10;        doctorInfo.put(&quot;availableTimes&quot;, doctor.getAvailableTimes());&#10;        doctorDetails.add(doctorInfo);&#10;    }&#10;    response.put(&quot;doctors&quot;, doctorDetails);&#10;    return response;&#10;}&#10;&#10;// 11. **filterDoctorsByNameSpecilityandTime Method**:&#10;//    - Filters doctors based on their name, specialty, and availability during a specific time (AM/PM).&#10;//    - The method fetches doctors matching the name and specialty criteria, then filters them based on their availability during the specified time period.&#10;//    - Instruction: Ensure proper filtering based on both the name and specialty as well as the specified time period.&#10;@Transactional&#10;    public Map&lt;String, Object&gt; filterDoctorsByNameSpecialtyAndTime(String name, String specialty, String amOrPm) {&#10;    Map&lt;String, Object&gt; response = new HashMap&lt;&gt;();&#10;    List&lt;Doctor&gt; doctors = doctorRepository.findByNameContainingIgnoreCaseAndSpecialtyIgnoreCase(name, specialty);&#10;    List&lt;Doctor&gt; filteredDoctors = filterDoctorByTime(doctors, amOrPm);&#10;    if (filteredDoctors.isEmpty()) {&#10;        response.put(&quot;message&quot;, &quot;No doctors found matching the criteria.&quot;);&#10;        return response;&#10;    }&#10;    List&lt;Map&lt;String, Object&gt;&gt; doctorDetails = new ArrayList&lt;&gt;();&#10;    for (Doctor doctor : filteredDoctors) {&#10;        Map&lt;String, Object&gt; doctorInfo = new HashMap&lt;&gt;();&#10;        doctorInfo.put(&quot;id&quot;, doctor.getId());&#10;        doctorInfo.put(&quot;name&quot;, doctor.getName());&#10;        doctorInfo.put(&quot;specialty&quot;, doctor.getSpecialty());&#10;        doctorInfo.put(&quot;availableTimes&quot;, doctor.getAvailableTimes());&#10;        doctorDetails.add(doctorInfo);&#10;    }&#10;    response.put(&quot;doctors&quot;, doctorDetails);&#10;    return response;&#10;}&#10;// 12. **filterDoctorByTime Method**:&#10;//    - Filters a list of doctors based on whether their available times match the specified time period (AM/PM).&#10;//    - This method processes a list of doctors and their available times to return those that fit the time criteria.&#10;//    - Instruction: Ensure that the time filtering logic correctly handles both AM and PM time slots and edge cases.&#10;public List&lt;Doctor&gt; filterDoctorByTime(List&lt;Doctor&gt; doctors, String amOrPm) {&#10;    List&lt;Doctor&gt; filteredDoctors = new ArrayList&lt;&gt;();&#10;    for (Doctor doctor : doctors) {&#10;        List&lt;String&gt; availableTimes = doctor.getAvailableTimes();&#10;        boolean isAvailable = false;&#10;        for (String time : availableTimes) {&#10;            if (time.toLowerCase().contains(amOrPm.toLowerCase())) {&#10;                isAvailable = true;&#10;                break;&#10;            }&#10;        }&#10;        if (isAvailable) {&#10;            filteredDoctors.add(doctor);&#10;        }&#10;    }&#10;    return filteredDoctors;&#10;}&#10;// 13. **filterDoctorByNameAndTime Method**:&#10;//    - Filters doctors based on their name and the specified time period (AM/PM).&#10;//    - Fetches doctors based on partial name matching and filters the results to include only those available during the specified time period.&#10;//    - Instruction: Ensure that the method correctly filters doctors based on the given name and time of day (AM/PM).&#10;@Transactional&#10;public Map&lt;String, Object&gt; filterDoctorByNameAndTime(String name, String amOrPm) {&#10;    Map&lt;String, Object&gt; response = new HashMap&lt;&gt;();&#10;    List&lt;Doctor&gt; doctors = doctorRepository.findByNameLike(name);&#10;    List&lt;Doctor&gt; filteredDoctors = filterDoctorByTime(doctors, amOrPm);&#10;    if (filteredDoctors.isEmpty()) {&#10;        response.put(&quot;message&quot;, &quot;No doctors found matching the criteria.&quot;);&#10;        return response;&#10;    }&#10;    List&lt;Map&lt;String, Object&gt;&gt; doctorDetails = new ArrayList&lt;&gt;();&#10;    for (Doctor doctor : filteredDoctors) {&#10;        Map&lt;String, Object&gt; doctorInfo = new HashMap&lt;&gt;();&#10;        doctorInfo.put(&quot;id&quot;, doctor.getId());&#10;        doctorInfo.put(&quot;name&quot;, doctor.getName());&#10;        doctorInfo.put(&quot;specialty&quot;, doctor.getSpecialty());&#10;        doctorInfo.put(&quot;availableTimes&quot;, doctor.getAvailableTimes());&#10;        doctorDetails.add(doctorInfo);&#10;    }&#10;    response.put(&quot;doctors&quot;, doctorDetails);&#10;    return response;&#10;}&#10;// 14. **filterDoctorByNameAndSpecility Method**:&#10;//    - Filters doctors by name and specialty.&#10;//    - It ensures that the resulting list of doctors matches both the name (case-insensitive) and the specified specialty.&#10;//    - Instruction: Ensure that both name and specialty are considered when filtering doctors.&#10;@Transactional&#10;    public Map&lt;String, Object&gt; filterDoctorByNameAndSpecialty(String name, String specialty) {&#10;    Map&lt;String, Object&gt; response = new HashMap&lt;&gt;();&#10;    List&lt;Doctor&gt; doctors = doctorRepository.findByNameContainingIgnoreCaseAndSpecialtyIgnoreCase(name, specialty);&#10;    if (doctors.isEmpty()) {&#10;        response.put(&quot;message&quot;, &quot;No doctors found matching the criteria.&quot;);&#10;        return response;&#10;    }&#10;    List&lt;Map&lt;String, Object&gt;&gt; doctorDetails = new ArrayList&lt;&gt;();&#10;    for (Doctor doctor : doctors) {&#10;        Map&lt;String, Object&gt; doctorInfo = new HashMap&lt;&gt;();&#10;        doctorInfo.put(&quot;id&quot;, doctor.getId());&#10;        doctorInfo.put(&quot;name&quot;, doctor.getName());&#10;        doctorInfo.put(&quot;specialty&quot;, doctor.getSpecialty());&#10;        doctorInfo.put(&quot;availableTimes&quot;, doctor.getAvailableTimes());&#10;        doctorDetails.add(doctorInfo);&#10;    }&#10;    response.put(&quot;doctors&quot;, doctorDetails);&#10;    return response;&#10;}&#10;&#10;// 15. **filterDoctorByTimeAndSpecility Method**:&#10;//    - Filters doctors based on their specialty and availability during a specific time period (AM/PM).&#10;//    - Fetches doctors based on the specified specialty and filters them based on their available time slots for AM/PM.&#10;//    - Instruction: Ensure the time filtering is accurately applied based on the given specialty and time period (AM/PM).&#10;@Transactional&#10;public Map&lt;String, Object&gt; filterDoctorByTimeAndSpecialty(String specialty, String amOrPm) {&#10;    Map&lt;String, Object&gt; response = new HashMap&lt;&gt;();&#10;    List&lt;Doctor&gt; doctors = doctorRepository.findBySpecialtyIgnoreCase(specialty);&#10;    List&lt;Doctor&gt; filteredDoctors = filterDoctorByTime(doctors, amOrPm);&#10;    if (filteredDoctors.isEmpty()) {&#10;        response.put(&quot;message&quot;, &quot;No doctors found matching the criteria.&quot;);&#10;        return response;&#10;    }&#10;    List&lt;Map&lt;String, Object&gt;&gt; doctorDetails = new ArrayList&lt;&gt;();&#10;    for (Doctor doctor : filteredDoctors) {&#10;        Map&lt;String, Object&gt; doctorInfo = new HashMap&lt;&gt;();&#10;        doctorInfo.put(&quot;id&quot;, doctor.getId());&#10;        doctorInfo.put(&quot;name&quot;, doctor.getName());&#10;        doctorInfo.put(&quot;specialty&quot;, doctor.getSpecialty());&#10;        doctorInfo.put(&quot;availableTimes&quot;, doctor.getAvailableTimes());&#10;        doctorDetails.add(doctorInfo);&#10;    }&#10;    response.put(&quot;doctors&quot;, doctorDetails);&#10;    return response;&#10;}&#10;// 16. **filterDoctorBySpecility Method**:&#10;//    - Filters doctors based on their specialty.&#10;//    - This method fetches all doctors matching the specified specialty and returns them.&#10;//    - Instruction: Make sure the filtering logic works for case-insensitive specialty matching.&#10;public Map&lt;String, Object&gt; filterDoctorBySpecialty(String specialty) {&#10;    Map&lt;String, Object&gt; response = new HashMap&lt;&gt;();&#10;    List&lt;Doctor&gt; doctors = doctorRepository.findBySpecialtyIgnoreCase(specialty);&#10;    if (doctors.isEmpty()) {&#10;        response.put(&quot;message&quot;, &quot;No doctors found with the specialty: &quot; + specialty);&#10;        return response;&#10;    }&#10;    List&lt;Map&lt;String, Object&gt;&gt; doctorDetails = new ArrayList&lt;&gt;();&#10;    for (Doctor doctor : doctors) {&#10;        Map&lt;String, Object&gt; doctorInfo = new HashMap&lt;&gt;();&#10;        doctorInfo.put(&quot;id&quot;, doctor.getId());&#10;        doctorInfo.put(&quot;name&quot;, doctor.getName());&#10;        doctorInfo.put(&quot;specialty&quot;, doctor.getSpecialty());&#10;        doctorInfo.put(&quot;availableTimes&quot;, doctor.getAvailableTimes());&#10;        doctorDetails.add(doctorInfo);&#10;    }&#10;    response.put(&quot;doctors&quot;, doctorDetails);&#10;    return response;&#10;}&#10;// 17. **filterDoctorsByTime Method**:&#10;//    - Filters all doctors based on their availability during a specific time period (AM/PM).&#10;//    - The method checks all doctors' available times and returns those available during the specified time period.&#10;//    - Instruction: Ensure proper filtering logic to handle AM/PM time periods.&#10;public Map&lt;String, Object&gt; filterDoctorsByTime(String amOrPm) {&#10;    Map&lt;String, Object&gt; response = new HashMap&lt;&gt;();&#10;    List&lt;Doctor&gt; doctors = doctorRepository.findAll();&#10;    List&lt;Doctor&gt; filteredDoctors = filterDoctorByTime(doctors, amOrPm);&#10;    if (filteredDoctors.isEmpty()) {&#10;        response.put(&quot;message&quot;, &quot;No doctors found available during &quot; + amOrPm);&#10;        return response;&#10;    }&#10;    List&lt;Map&lt;String, Object&gt;&gt; doctorDetails = new ArrayList&lt;&gt;();&#10;    for (Doctor doctor : filteredDoctors) {&#10;        Map&lt;String, Object&gt; doctorInfo = new HashMap&lt;&gt;();&#10;        doctorInfo.put(&quot;id&quot;, doctor.getId());&#10;        doctorInfo.put(&quot;name&quot;, doctor.getName());&#10;        doctorInfo.put(&quot;specialty&quot;, doctor.getSpecialty());&#10;        doctorInfo.put(&quot;availableTimes&quot;, doctor.getAvailableTimes());&#10;        doctorDetails.add(doctorInfo);&#10;    }&#10;    response.put(&quot;doctors&quot;, doctorDetails);&#10;    return response;&#10;}&#10;}&#10;" />
              <option name="updatedContent" value="package com.project.back_end.services;&#10;&#10;import com.project.back_end.models.Appointment;&#10;import com.project.back_end.models.Doctor;&#10;import com.project.back_end.repo.AppointmentRepository;&#10;import com.project.back_end.repo.DoctorRepository;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.stereotype.Service;&#10;import org.springframework.transaction.annotation.Transactional;&#10;import com.project.back_end.DTO.Login;&#10;&#10;import javax.print.Doc;&#10;import java.time.LocalDate;&#10;import java.time.LocalDateTime;&#10;import java.time.LocalTime;&#10;import java.time.format.DateTimeFormatter;&#10;import java.util.*;&#10;import java.util.stream.Collectors;&#10;&#10;@Service&#10;public class DoctorService {&#10;&#10;// 1. **Add @Service Annotation**:&#10;//    - This class should be annotated with `@Service` to indicate that it is a service layer class.&#10;//    - The `@Service` annotation marks this class as a Spring-managed bean for business logic.&#10;//    - Instruction: Add `@Service` above the class declaration.&#10;&#10;// 2. **Constructor Injection for Dependencies**:&#10;//    - The `DoctorService` class depends on `DoctorRepository`, `AppointmentRepository`, and `TokenService`.&#10;//    - These dependencies should be injected via the constructor for proper dependency management.&#10;//    - Instruction: Ensure constructor injection is used for injecting dependencies into the service.&#10;private final DoctorRepository doctorRepository;&#10;private  final AppointmentRepository appointmentRepository;&#10;private  final TokenService tokenService;&#10;public DoctorService (DoctorRepository doctorRepository,&#10;                        AppointmentRepository appointmentRepository,&#10;                        TokenService tokenService) {&#10;    this.doctorRepository = doctorRepository;&#10;    this.appointmentRepository = appointmentRepository;&#10;    this.tokenService = tokenService;&#10;}&#10;// 3. **Add @Transactional Annotation for Methods that Modify or Fetch Database Data**:&#10;//    - Methods like `getDoctorAvailability`, `getDoctors`, `findDoctorByName`, `filterDoctorsBy*` should be annotated with `@Transactional`.&#10;//    - The `@Transactional` annotation ensures that database operations are consistent and wrapped in a single transaction.&#10;//    - Instruction: Add the `@Transactional` annotation above the methods that perform database operations or queries.&#10;&#10;// 4. **getDoctorAvailability Method**:&#10;//    - Retrieves the available time slots for a specific doctor on a particular date and filters out already booked slots.&#10;//    - The method fetches all appointments for the doctor on the given date and calculates the availability by comparing against booked slots.&#10;//    - Instruction: Ensure that the time slots are properly formatted and the available slots are correctly filtered.&#10;@Transactional&#10;public List&lt;String&gt; getDoctorAvailability(Long doctorId, LocalDate date) {&#10;    Optional&lt;Doctor&gt; doctor = doctorRepository.findById(doctorId);&#10;&#10;    if (doctor.isEmpty()) {&#10;        return List.of(&quot;Doctor not found with ID: &quot; + doctorId);&#10;    }&#10;&#10;    List&lt;String&gt; availableSlots = doctor.get().getAvailableTimes().stream()&#10;            .map(Object::toString)&#10;            .collect(Collectors.toList());&#10;&#10;    // Convert LocalDate to LocalDateTime (start and end of the day)&#10;    LocalDateTime startOfDay = date.atStartOfDay();&#10;    LocalDateTime endOfDay = date.atTime(LocalTime.MAX);&#10;&#10;    // Fetch the appointments for this doctor on the given date&#10;    List&lt;Appointment&gt; appointments = appointmentRepository.findByDoctorIdAndAppointmentTimeBetween(doctorId,&#10;            startOfDay, endOfDay);&#10;&#10;    // Set of booked slots for the doctor on this date&#10;    Set&lt;String&gt; bookedSlots = appointments.stream()&#10;            .map(appt -&gt; {&#10;                LocalDateTime start = appt.getAppointmentTime();&#10;                LocalDateTime end = start.plusHours(1); // Add 1 hour to the start time to get the end time&#10;                return formatSlot(start, end); // Format the slot as &quot;HH:mm-HH:mm&quot;&#10;            })&#10;            .collect(Collectors.toSet());&#10;&#10;    // Filter out booked slots from the available slots&#10;    return availableSlots.stream()&#10;            .filter(slot -&gt; !bookedSlots.contains(slot))&#10;            .collect(Collectors.toList());&#10;}&#10;private String formatSlot(LocalDateTime start, LocalDateTime end) {&#10;    DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;HH:mm&quot;);&#10;    return start.format(formatter) + &quot;-&quot; + end.format(formatter);&#10;}&#10;&#10;// 5. **saveDoctor Method**:&#10;//    - Used to save a new doctor record in the database after checking if a doctor with the same email already exists.&#10;//    - If a doctor with the same email is found, it returns `-1` to indicate conflict; `1` for success, and `0` for internal errors.&#10;//    - Instruction: Ensure that the method correctly handles conflicts and exceptions when saving a doctor.&#10;&#10;public int saveDoctor(Doctor doctor) {&#10;&#10;    // success: 1, conflict:-1, internal error: 0&#10;    Doctor result = doctorRepository.findByEmail(doctor.getEmail());&#10;&#10;    if (result != null) {&#10;        return -1;&#10;    }&#10;    try {&#10;        doctorRepository.save(doctor);&#10;        return 1;&#10;    } catch (Exception e) {&#10;        System.err.println(&quot;Error saving doctor: &quot; + e.getMessage());&#10;        return 0;&#10;    }&#10;&#10;}&#10;// 6. **updateDoctor Method**:&#10;//    - Updates an existing doctor's details in the database. If the doctor doesn't exist, it returns `-1`.&#10;//    - Instruction: Make sure that the doctor exists before attempting to save the updated record and handle any errors properly.&#10;&#10;public int updateDoctor(Doctor doctor) {&#10;    Optional&lt;Doctor&gt; existingDoctor = doctorRepository.findById(doctor.getId());&#10;    if (existingDoctor.isEmpty()) {&#10;        return -1; // Doctor not found&#10;    }&#10;    try {&#10;        doctorRepository.save(doctor);&#10;        return 1; // Update successful&#10;    } catch (Exception e) {&#10;        System.err.println(&quot;Error updating doctor: &quot; + e.getMessage());&#10;        return 0; // Internal error&#10;    }&#10;}&#10;// 7. **getDoctors Method**:&#10;//    - Fetches all doctors from the database. It is marked with `@Transactional` to ensure that the collection is properly loaded.&#10;//    - Instruction: Ensure that the collection is eagerly loaded, especially if dealing with lazy-loaded relationships (e.g., available times). &#10;@Transactional&#10;public List&lt;Doctor&gt; getDoctors() {&#10;    return doctorRepository.findAll();&#10;}&#10;// 8. **deleteDoctor Method**:&#10;//    - Deletes a doctor from the system along with all appointments associated with that doctor.&#10;//    - It first checks if the doctor exists. If not, it returns `-1`; otherwise, it deletes the doctor and their appointments.&#10;//    - Instruction: Ensure the doctor and their appointments are deleted properly, with error handling for internal issues.&#10;public int deleteDoctor(Long doctorId) {&#10;    Optional&lt;Doctor&gt; doctor = doctorRepository.findById(doctorId);&#10;    if (doctor.isEmpty()) {&#10;        return -1; // Doctor not found&#10;    }&#10;    try {&#10;        // Delete all appointments associated with the doctor&#10;        appointmentRepository.deleteAllByDoctorId(doctorId);&#10;        // Delete the doctor&#10;        doctorRepository.delete(doctor.get());&#10;        return 1; // Deletion successful&#10;    } catch (Exception e) {&#10;        System.err.println(&quot;Error deleting doctor: &quot; + e.getMessage());&#10;        return 0; // Internal error&#10;    }&#10;}&#10;&#10;// 9. **validateDoctor Method**:&#10;//    - Validates a doctor's login by checking if the email and password match an existing doctor record.&#10;//    - It generates a token for the doctor if the login is successful, otherwise returns an error message.&#10;//    - Instruction: Make sure to handle invalid login attempts and password mismatches properly with error responses.&#10;public ResponseEntity&lt;Map&lt;String, String&gt;&gt; ValidateDoctor(Login login) {&#10;    Map&lt;String, String&gt; map = new HashMap&lt;&gt;();&#10;    try {&#10;        System.out.println(&quot;=== DOCTOR LOGIN START ===&quot;);&#10;        System.out.println(&quot;Login attempt for email: &quot; + login.getEmail());&#10;&#10;        Doctor doctor = doctorRepository.findByEmail(login.getEmail());&#10;        if (doctor == null) {&#10;            System.out.println(&quot;Doctor not found in database for email: &quot; + login.getEmail());&#10;            map.put(&quot;message&quot;, &quot;Doctor not found&quot;);&#10;            return ResponseEntity.badRequest().body(map);&#10;        }&#10;&#10;        System.out.println(&quot;Doctor found: &quot; + doctor.getName() + &quot; (ID: &quot; + doctor.getId() + &quot;)&quot;);&#10;&#10;        if (!doctor.getPassword().equals(login.getPassword())) {&#10;            System.out.println(&quot;Password mismatch for doctor: &quot; + login.getEmail());&#10;            map.put(&quot;message&quot;, &quot;Invalid password&quot;);&#10;            return ResponseEntity.badRequest().body(map);&#10;        }&#10;&#10;        System.out.println(&quot;Password verified successfully&quot;);&#10;        System.out.println(&quot;Generating token for doctor email: &quot; + doctor.getEmail());&#10;&#10;        String token = tokenService.generateToken(doctor.getEmail());&#10;        System.out.println(&quot;Token generated successfully: &quot; + token.substring(0, Math.min(20, token.length())) + &quot;...&quot;);&#10;&#10;        map.put(&quot;token&quot;, token);&#10;        map.put(&quot;message&quot;, &quot;Login successful&quot;);&#10;        System.out.println(&quot;=== DOCTOR LOGIN SUCCESS ===&quot;);&#10;        return ResponseEntity.ok(map);&#10;    } catch (Exception e) {&#10;        System.err.println(&quot;Error in ValidateDoctor: &quot; + e.getMessage());&#10;        e.printStackTrace();&#10;        map.put(&quot;message&quot;, &quot;Internal error: &quot; + e.getMessage());&#10;        return ResponseEntity.status(500).body(map);&#10;    }&#10;}&#10;// 10. **findDoctorByName Method**:&#10;//    - Finds doctors based on partial name matching and returns the list of doctors with their available times.&#10;//    - This method is annotated with `@Transactional` to ensure that the database query and data retrieval are properly managed within a transaction.&#10;//    - Instruction: Ensure that available times are eagerly loaded for the doctors.&#10;public Map&lt;String, Object&gt; findDoctorByName(String name){&#10;    Map&lt;String, Object&gt; response = new HashMap&lt;&gt;();&#10;    try {&#10;        // Add % wildcards for LIKE pattern matching and use the ContainingIgnoreCase method&#10;        List&lt;Doctor&gt; doctors = doctorRepository.findByNameContainingIgnoreCase(name);&#10;        if (doctors.isEmpty()) {&#10;            response.put(&quot;message&quot;, &quot;No doctors found with the name: &quot; + name);&#10;            return response;&#10;        }&#10;        List&lt;Map&lt;String, Object&gt;&gt; doctorDetails = new ArrayList&lt;&gt;();&#10;        for (Doctor doctor : doctors) {&#10;            Map&lt;String, Object&gt; doctorInfo = new HashMap&lt;&gt;();&#10;            doctorInfo.put(&quot;id&quot;, doctor.getId());&#10;            doctorInfo.put(&quot;name&quot;, doctor.getName());&#10;            doctorInfo.put(&quot;specialty&quot;, doctor.getSpecialty());&#10;            doctorInfo.put(&quot;availableTimes&quot;, doctor.getAvailableTimes());&#10;            doctorDetails.add(doctorInfo);&#10;        }&#10;        response.put(&quot;doctors&quot;, doctorDetails);&#10;        return response;&#10;    } catch (Exception e) {&#10;        response.put(&quot;message&quot;, &quot;Error searching for doctors: &quot; + e.getMessage());&#10;        return response;&#10;    }&#10;}&#10;&#10;// 11. **filterDoctorsByNameSpecilityandTime Method**:&#10;//    - Filters doctors based on their name, specialty, and availability during a specific time (AM/PM).&#10;//    - The method fetches doctors matching the name and specialty criteria, then filters them based on their availability during the specified time period.&#10;//    - Instruction: Ensure proper filtering based on both the name and specialty as well as the specified time period.&#10;@Transactional&#10;    public Map&lt;String, Object&gt; filterDoctorsByNameSpecialtyAndTime(String name, String specialty, String amOrPm) {&#10;    Map&lt;String, Object&gt; response = new HashMap&lt;&gt;();&#10;    List&lt;Doctor&gt; doctors = doctorRepository.findByNameContainingIgnoreCaseAndSpecialtyIgnoreCase(name, specialty);&#10;    List&lt;Doctor&gt; filteredDoctors = filterDoctorByTime(doctors, amOrPm);&#10;    if (filteredDoctors.isEmpty()) {&#10;        response.put(&quot;message&quot;, &quot;No doctors found matching the criteria.&quot;);&#10;        return response;&#10;    }&#10;    List&lt;Map&lt;String, Object&gt;&gt; doctorDetails = new ArrayList&lt;&gt;();&#10;    for (Doctor doctor : filteredDoctors) {&#10;        Map&lt;String, Object&gt; doctorInfo = new HashMap&lt;&gt;();&#10;        doctorInfo.put(&quot;id&quot;, doctor.getId());&#10;        doctorInfo.put(&quot;name&quot;, doctor.getName());&#10;        doctorInfo.put(&quot;specialty&quot;, doctor.getSpecialty());&#10;        doctorInfo.put(&quot;availableTimes&quot;, doctor.getAvailableTimes());&#10;        doctorDetails.add(doctorInfo);&#10;    }&#10;    response.put(&quot;doctors&quot;, doctorDetails);&#10;    return response;&#10;}&#10;// 12. **filterDoctorByTime Method**:&#10;//    - Filters a list of doctors based on whether their available times match the specified time period (AM/PM).&#10;//    - This method processes a list of doctors and their available times to return those that fit the time criteria.&#10;//    - Instruction: Ensure that the time filtering logic correctly handles both AM and PM time slots and edge cases.&#10;public List&lt;Doctor&gt; filterDoctorByTime(List&lt;Doctor&gt; doctors, String amOrPm) {&#10;    List&lt;Doctor&gt; filteredDoctors = new ArrayList&lt;&gt;();&#10;    for (Doctor doctor : doctors) {&#10;        List&lt;String&gt; availableTimes = doctor.getAvailableTimes();&#10;        boolean isAvailable = false;&#10;        for (String time : availableTimes) {&#10;            if (time.toLowerCase().contains(amOrPm.toLowerCase())) {&#10;                isAvailable = true;&#10;                break;&#10;            }&#10;        }&#10;        if (isAvailable) {&#10;            filteredDoctors.add(doctor);&#10;        }&#10;    }&#10;    return filteredDoctors;&#10;}&#10;// 13. **filterDoctorByNameAndTime Method**:&#10;//    - Filters doctors based on their name and the specified time period (AM/PM).&#10;//    - Fetches doctors based on partial name matching and filters the results to include only those available during the specified time period.&#10;//    - Instruction: Ensure that the method correctly filters doctors based on the given name and time of day (AM/PM).&#10;@Transactional&#10;public Map&lt;String, Object&gt; filterDoctorByNameAndTime(String name, String amOrPm) {&#10;    Map&lt;String, Object&gt; response = new HashMap&lt;&gt;();&#10;    try {&#10;        // Changed from findByNameLike to findByNameContainingIgnoreCase for proper pattern matching&#10;        List&lt;Doctor&gt; doctors = doctorRepository.findByNameContainingIgnoreCase(name);&#10;        List&lt;Doctor&gt; filteredDoctors = filterDoctorByTime(doctors, amOrPm);&#10;        if (filteredDoctors.isEmpty()) {&#10;            response.put(&quot;message&quot;, &quot;No doctors found matching the criteria.&quot;);&#10;            return response;&#10;        }&#10;        List&lt;Map&lt;String, Object&gt;&gt; doctorDetails = new ArrayList&lt;&gt;();&#10;        for (Doctor doctor : filteredDoctors) {&#10;            Map&lt;String, Object&gt; doctorInfo = new HashMap&lt;&gt;();&#10;            doctorInfo.put(&quot;id&quot;, doctor.getId());&#10;            doctorInfo.put(&quot;name&quot;, doctor.getName());&#10;            doctorInfo.put(&quot;specialty&quot;, doctor.getSpecialty());&#10;            doctorInfo.put(&quot;availableTimes&quot;, doctor.getAvailableTimes());&#10;            doctorDetails.add(doctorInfo);&#10;        }&#10;        response.put(&quot;doctors&quot;, doctorDetails);&#10;        return response;&#10;    } catch (Exception e) {&#10;        response.put(&quot;message&quot;, &quot;Error filtering doctors by name and time: &quot; + e.getMessage());&#10;        return response;&#10;    }&#10;}&#10;// 14. **filterDoctorByNameAndSpecility Method**:&#10;//    - Filters doctors by name and specialty.&#10;//    - It ensures that the resulting list of doctors matches both the name (case-insensitive) and the specified specialty.&#10;//    - Instruction: Ensure that both name and specialty are considered when filtering doctors.&#10;@Transactional&#10;    public Map&lt;String, Object&gt; filterDoctorByNameAndSpecialty(String name, String specialty) {&#10;    Map&lt;String, Object&gt; response = new HashMap&lt;&gt;();&#10;    List&lt;Doctor&gt; doctors = doctorRepository.findByNameContainingIgnoreCaseAndSpecialtyIgnoreCase(name, specialty);&#10;    if (doctors.isEmpty()) {&#10;        response.put(&quot;message&quot;, &quot;No doctors found matching the criteria.&quot;);&#10;        return response;&#10;    }&#10;    List&lt;Map&lt;String, Object&gt;&gt; doctorDetails = new ArrayList&lt;&gt;();&#10;    for (Doctor doctor : doctors) {&#10;        Map&lt;String, Object&gt; doctorInfo = new HashMap&lt;&gt;();&#10;        doctorInfo.put(&quot;id&quot;, doctor.getId());&#10;        doctorInfo.put(&quot;name&quot;, doctor.getName());&#10;        doctorInfo.put(&quot;specialty&quot;, doctor.getSpecialty());&#10;        doctorInfo.put(&quot;availableTimes&quot;, doctor.getAvailableTimes());&#10;        doctorDetails.add(doctorInfo);&#10;    }&#10;    response.put(&quot;doctors&quot;, doctorDetails);&#10;    return response;&#10;}&#10;&#10;// 15. **filterDoctorByTimeAndSpecility Method**:&#10;//    - Filters doctors based on their specialty and availability during a specific time period (AM/PM).&#10;//    - Fetches doctors based on the specified specialty and filters them based on their available time slots for AM/PM.&#10;//    - Instruction: Ensure the time filtering is accurately applied based on the given specialty and time period (AM/PM).&#10;@Transactional&#10;public Map&lt;String, Object&gt; filterDoctorByTimeAndSpecialty(String specialty, String amOrPm) {&#10;    Map&lt;String, Object&gt; response = new HashMap&lt;&gt;();&#10;    List&lt;Doctor&gt; doctors = doctorRepository.findBySpecialtyIgnoreCase(specialty);&#10;    List&lt;Doctor&gt; filteredDoctors = filterDoctorByTime(doctors, amOrPm);&#10;    if (filteredDoctors.isEmpty()) {&#10;        response.put(&quot;message&quot;, &quot;No doctors found matching the criteria.&quot;);&#10;        return response;&#10;    }&#10;    List&lt;Map&lt;String, Object&gt;&gt; doctorDetails = new ArrayList&lt;&gt;();&#10;    for (Doctor doctor : filteredDoctors) {&#10;        Map&lt;String, Object&gt; doctorInfo = new HashMap&lt;&gt;();&#10;        doctorInfo.put(&quot;id&quot;, doctor.getId());&#10;        doctorInfo.put(&quot;name&quot;, doctor.getName());&#10;        doctorInfo.put(&quot;specialty&quot;, doctor.getSpecialty());&#10;        doctorInfo.put(&quot;availableTimes&quot;, doctor.getAvailableTimes());&#10;        doctorDetails.add(doctorInfo);&#10;    }&#10;    response.put(&quot;doctors&quot;, doctorDetails);&#10;    return response;&#10;}&#10;// 16. **filterDoctorBySpecility Method**:&#10;//    - Filters doctors based on their specialty.&#10;//    - This method fetches all doctors matching the specified specialty and returns them.&#10;//    - Instruction: Make sure the filtering logic works for case-insensitive specialty matching.&#10;public Map&lt;String, Object&gt; filterDoctorBySpecialty(String specialty) {&#10;    Map&lt;String, Object&gt; response = new HashMap&lt;&gt;();&#10;    List&lt;Doctor&gt; doctors = doctorRepository.findBySpecialtyIgnoreCase(specialty);&#10;    if (doctors.isEmpty()) {&#10;        response.put(&quot;message&quot;, &quot;No doctors found with the specialty: &quot; + specialty);&#10;        return response;&#10;    }&#10;    List&lt;Map&lt;String, Object&gt;&gt; doctorDetails = new ArrayList&lt;&gt;();&#10;    for (Doctor doctor : doctors) {&#10;        Map&lt;String, Object&gt; doctorInfo = new HashMap&lt;&gt;();&#10;        doctorInfo.put(&quot;id&quot;, doctor.getId());&#10;        doctorInfo.put(&quot;name&quot;, doctor.getName());&#10;        doctorInfo.put(&quot;specialty&quot;, doctor.getSpecialty());&#10;        doctorInfo.put(&quot;availableTimes&quot;, doctor.getAvailableTimes());&#10;        doctorDetails.add(doctorInfo);&#10;    }&#10;    response.put(&quot;doctors&quot;, doctorDetails);&#10;    return response;&#10;}&#10;// 17. **filterDoctorsByTime Method**:&#10;//    - Filters all doctors based on their availability during a specific time period (AM/PM).&#10;//    - The method checks all doctors' available times and returns those available during the specified time period.&#10;//    - Instruction: Ensure proper filtering logic to handle AM/PM time periods.&#10;public Map&lt;String, Object&gt; filterDoctorsByTime(String amOrPm) {&#10;    Map&lt;String, Object&gt; response = new HashMap&lt;&gt;();&#10;    List&lt;Doctor&gt; doctors = doctorRepository.findAll();&#10;    List&lt;Doctor&gt; filteredDoctors = filterDoctorByTime(doctors, amOrPm);&#10;    if (filteredDoctors.isEmpty()) {&#10;        response.put(&quot;message&quot;, &quot;No doctors found available during &quot; + amOrPm);&#10;        return response;&#10;    }&#10;    List&lt;Map&lt;String, Object&gt;&gt; doctorDetails = new ArrayList&lt;&gt;();&#10;    for (Doctor doctor : filteredDoctors) {&#10;        Map&lt;String, Object&gt; doctorInfo = new HashMap&lt;&gt;();&#10;        doctorInfo.put(&quot;id&quot;, doctor.getId());&#10;        doctorInfo.put(&quot;name&quot;, doctor.getName());&#10;        doctorInfo.put(&quot;specialty&quot;, doctor.getSpecialty());&#10;        doctorInfo.put(&quot;availableTimes&quot;, doctor.getAvailableTimes());&#10;        doctorDetails.add(doctorInfo);&#10;    }&#10;    response.put(&quot;doctors&quot;, doctorDetails);&#10;    return response;&#10;}&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/project/back_end/services/TokenService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/project/back_end/services/TokenService.java" />
              <option name="originalContent" value="package com.project.back_end.services;&#10;&#10;import com.project.back_end.repo.AdminRepository;&#10;import com.project.back_end.repo.DoctorRepository;&#10;import com.project.back_end.repo.PatientRepository;&#10;import io.jsonwebtoken.Jwts;&#10;import io.jsonwebtoken.security.Keys;&#10;import org.springframework.beans.factory.annotation.Value;&#10;import org.springframework.stereotype.Component;&#10;&#10;import javax.crypto.SecretKey;&#10;import java.util.Date;&#10;&#10;@Component&#10;public class TokenService {&#10;// 1. **@Component Annotation**&#10;// The @Component annotation marks this class as a Spring component, meaning Spring will manage it as a bean within its application context.&#10;// This allows the class to be injected into other Spring-managed components (like services or controllers) where it's needed.&#10;&#10;// 2. **Constructor Injection for Dependencies**&#10;// The constructor injects dependencies for `AdminRepository`, `DoctorRepository`, and `PatientRepository`,&#10;// allowing the service to interact with the database and validate users based on their role (admin, doctor, or patient).&#10;// Constructor injection ensures that the class is initialized with all required dependencies, promoting immutability and making the class testable.&#10;private final AdminRepository adminRepository;&#10;private final DoctorRepository doctorRepository;&#10;private final PatientRepository patientRepository;&#10;public TokenService(AdminRepository adminRepository, DoctorRepository doctorRepository, PatientRepository patientRepository) {&#10;    this.adminRepository = adminRepository;&#10;    this.doctorRepository = doctorRepository;&#10;    this.patientRepository = patientRepository;&#10;}&#10;// 3. **getSigningKey Method**&#10;// This method retrieves the HMAC SHA key used to sign JWT tokens.&#10;// It uses the `jwt.secret` value, which is provided from an external source (like application properties).&#10;// The `Keys.hmacShaKeyFor()` method converts the secret key string into a valid `SecretKey` for signing and verification of JWTs.&#10;@Value(&quot;${jwt.secret}&quot;)&#10;private String jwtSecret;&#10;private SecretKey getSigningKey() {&#10;    return Keys.hmacShaKeyFor(jwtSecret.getBytes());&#10;}&#10;// 4. **generateToken Method**&#10;// This method generates a JWT token for a user based on their email.&#10;// - The `subject` of the token is set to the user's email, which is used as an identifier.&#10;// - The `issuedAt` is set to the current date and time.&#10;// - The `expiration` is set to 7 days from the issue date, ensuring the token expires after one week.&#10;// - The token is signed using the signing key generated by `getSigningKey()`, making it secure and tamper-proof.&#10;// The method returns the JWT token as a string.&#10;public String generateToken(String email) {&#10;    return Jwts.builder()&#10;            .subject(email)&#10;            .issuedAt(new Date())&#10;            .expiration(new Date(System.currentTimeMillis() + 1000L * 60 * 60 * 24 * 7)) // 7 days&#10;            .signWith(getSigningKey())&#10;            .compact();&#10;}&#10;// 5. **extractEmail Method**&#10;// This method extracts the user's email (subject) from the provided JWT token.&#10;// - The token is first verified using the signing key to ensure it hasnt been tampered with.&#10;// - After verification, the token is parsed, and the subject (which represents the email) is extracted.&#10;// This method allows the application to retrieve the user's identity (email) from the token for further use.&#10;public String extractEmail(String token) {&#10;    try {&#10;        return Jwts.parser()&#10;                .verifyWith(getSigningKey())&#10;                .build()&#10;                .parseClaimsJws(token)&#10;                .getPayload()&#10;                .getSubject();&#10;    } catch (Exception e) {&#10;        return null; // Return null if the token is invalid or an error occurs&#10;    }&#10;}&#10;// 6. **validateToken Method**&#10;// This method validates whether a provided JWT token is valid for a specific user role (admin, doctor, or patient).&#10;// - It first extracts the email from the token using the `extractEmail()` method.&#10;// - Depending on the role (`admin`, `doctor`, or `patient`), it checks the corresponding repository (AdminRepository, DoctorRepository, or PatientRepository)&#10;//   to see if a user with the extracted email exists.&#10;// - If a match is found for the specified user role, it returns true, indicating the token is valid.&#10;// - If the role or user does not exist, it returns false, indicating the token is invalid.&#10;// - The method gracefully handles any errors by returning false if the token is invalid or an exception occurs.&#10;// This ensures secure access control based on the user's role and their existence in the system.&#10;public boolean validateToken(String token, String role) {&#10;    try {&#10;&#10;            case &quot;doctor&quot; -&gt; doctorRepository.findByEmail(subject) != null;   // subject is email for doctor&#10;            default -&gt; false; // Invalid role&#10;        };&#10;    } catch (Exception e) {&#10;        return switch (role.toLowerCase()) {&#10;            case &quot;admin&quot; -&gt; adminRepository.findByUsername(subject) != null;  // subject is username for admin&#10;            case &quot;doctor&quot; -&gt; doctorRepository.findByEmail(subject) != null;   // subject is email for doctor&#10;            case &quot;patient&quot; -&gt; patientRepository.findByEmail(subject) != null; // subject is email for patient&#10;            default -&gt; false; // Invalid role&#10;" />
              <option name="updatedContent" value="package com.project.back_end.services;&#10;&#10;import com.project.back_end.repo.AdminRepository;&#10;import com.project.back_end.repo.DoctorRepository;&#10;import com.project.back_end.repo.PatientRepository;&#10;import io.jsonwebtoken.Jwts;&#10;import io.jsonwebtoken.security.Keys;&#10;import org.springframework.beans.factory.annotation.Value;&#10;import org.springframework.stereotype.Component;&#10;&#10;import javax.crypto.SecretKey;&#10;import java.util.Date;&#10;&#10;@Component&#10;public class TokenService {&#10;// 1. **@Component Annotation**&#10;// The @Component annotation marks this class as a Spring component, meaning Spring will manage it as a bean within its application context.&#10;// This allows the class to be injected into other Spring-managed components (like services or controllers) where it's needed.&#10;&#10;// 2. **Constructor Injection for Dependencies**&#10;// The constructor injects dependencies for `AdminRepository`, `DoctorRepository`, and `PatientRepository`,&#10;// allowing the service to interact with the database and validate users based on their role (admin, doctor, or patient).&#10;// Constructor injection ensures that the class is initialized with all required dependencies, promoting immutability and making the class testable.&#10;private final AdminRepository adminRepository;&#10;private final DoctorRepository doctorRepository;&#10;private final PatientRepository patientRepository;&#10;public TokenService(AdminRepository adminRepository, DoctorRepository doctorRepository, PatientRepository patientRepository) {&#10;    this.adminRepository = adminRepository;&#10;    this.doctorRepository = doctorRepository;&#10;    this.patientRepository = patientRepository;&#10;}&#10;// 3. **getSigningKey Method**&#10;// This method retrieves the HMAC SHA key used to sign JWT tokens.&#10;// It uses the `jwt.secret` value, which is provided from an external source (like application properties).&#10;// The `Keys.hmacShaKeyFor()` method converts the secret key string into a valid `SecretKey` for signing and verification of JWTs.&#10;@Value(&quot;${jwt.secret}&quot;)&#10;private String jwtSecret;&#10;private SecretKey getSigningKey() {&#10;    return Keys.hmacShaKeyFor(jwtSecret.getBytes());&#10;}&#10;// 4. **generateToken Method**&#10;// This method generates a JWT token for a user based on their email.&#10;// - The `subject` of the token is set to the user's email, which is used as an identifier.&#10;// - The `issuedAt` is set to the current date and time.&#10;// - The `expiration` is set to 7 days from the issue date, ensuring the token expires after one week.&#10;// - The token is signed using the signing key generated by `getSigningKey()`, making it secure and tamper-proof.&#10;// The method returns the JWT token as a string.&#10;public String generateToken(String email) {&#10;    return Jwts.builder()&#10;            .subject(email)&#10;            .issuedAt(new Date())&#10;            .expiration(new Date(System.currentTimeMillis() + 1000L * 60 * 60 * 24 * 7)) // 7 days&#10;            .signWith(getSigningKey())&#10;            .compact();&#10;}&#10;// 5. **extractEmail Method**&#10;// This method extracts the user's email (subject) from the provided JWT token.&#10;// - The token is first verified using the signing key to ensure it hasnt been tampered with.&#10;// - After verification, the token is parsed, and the subject (which represents the email) is extracted.&#10;// This method allows the application to retrieve the user's identity (email) from the token for further use.&#10;public String extractEmail(String token) {&#10;    try {&#10;        return Jwts.parser()&#10;                .verifyWith(getSigningKey())&#10;                .build()&#10;                .parseClaimsJws(token)&#10;                .getPayload()&#10;                .getSubject();&#10;    } catch (Exception e) {&#10;        return null; // Return null if the token is invalid or an error occurs&#10;    }&#10;}&#10;// 6. **validateToken Method**&#10;// This method validates whether a provided JWT token is valid for a specific user role (admin, doctor, or patient).&#10;// - It first extracts the email from the token using the `extractEmail()` method.&#10;// - Depending on the role (`admin`, `doctor`, or `patient`), it checks the corresponding repository (AdminRepository, DoctorRepository, or PatientRepository)&#10;//   to see if a user with the extracted email exists.&#10;// - If a match is found for the specified user role, it returns true, indicating the token is valid.&#10;// - If the role or user does not exist, it returns false, indicating the token is invalid.&#10;// - The method gracefully handles any errors by returning false if the token is invalid or an exception occurs.&#10;// This ensures secure access control based on the user's role and their existence in the system.&#10;public boolean validateToken(String token, String role) {&#10;    try {&#10;        System.out.println(&quot;=== TOKEN VALIDATION START ===&quot;);&#10;        System.out.println(&quot;Validating token for role: &quot; + role);&#10;        System.out.println(&quot;Token: &quot; + (token != null ? token.substring(0, Math.min(20, token.length())) + &quot;...&quot; : &quot;null&quot;));&#10;        &#10;        String subject = extractEmail(token);  // This extracts the subject from token&#10;        System.out.println(&quot;Extracted subject from token: &quot; + subject);&#10;        &#10;        if (subject == null) {&#10;            System.out.println(&quot;Token validation failed: subject is null&quot;);&#10;            return false; // Invalid token&#10;        }&#10;&#10;        boolean result = switch (role.toLowerCase()) {&#10;            case &quot;admin&quot; -&gt; {&#10;                boolean adminExists = adminRepository.findByUsername(subject) != null;&#10;                System.out.println(&quot;Admin validation - checking username: &quot; + subject + &quot;, exists: &quot; + adminExists);&#10;                yield adminExists;&#10;            }&#10;            case &quot;doctor&quot; -&gt; {&#10;                boolean doctorExists = doctorRepository.findByEmail(subject) != null;&#10;                System.out.println(&quot;Doctor validation - checking email: &quot; + subject + &quot;, exists: &quot; + doctorExists);&#10;                yield doctorExists;&#10;            }&#10;            case &quot;patient&quot; -&gt; {&#10;                boolean patientExists = patientRepository.findByEmail(subject) != null;&#10;                System.out.println(&quot;Patient validation - checking email: &quot; + subject + &quot;, exists: &quot; + patientExists);&#10;                yield patientExists;&#10;            }&#10;            default -&gt; {&#10;                System.out.println(&quot;Invalid role provided: &quot; + role);&#10;                yield false;&#10;            }&#10;        };&#10;        &#10;        System.out.println(&quot;Token validation result: &quot; + result);&#10;        System.out.println(&quot;=== TOKEN VALIDATION END ===&quot;);&#10;        return result;&#10;        &#10;    } catch (Exception e) {&#10;        System.err.println(&quot;Token validation error: &quot; + e.getMessage());&#10;        e.printStackTrace();&#10;        return false; // Handle any exceptions gracefully&#10;    }&#10;}&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>